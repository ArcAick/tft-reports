<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>SPARQL 1.1 Test Suite Report by TFT</title>


    <script class='remove'>
      var respecConfig = {
        specStatus: "ED",
        editors: [
		{
		  name: "Karima Rafes",
                    url:        "http://karimarafes.me/",
                    company:    "BorderCloud",
                    companyURL: "http://bordercloud.com"
		},
		{
		  name: "Axel Polleres",
                    company: "Siemens AG"
		},
		{
		  name: "Steve Harris",
                  company: "IAM Research Group, Southampton"
		},
		{
		  name: "Jeen Broekstra",
                  company: "Information Systems Group, Eindhoven University of Technology"
		},
		{
		  name: "Lee Feigenbaum",
                  company: "Cambridge Semantics"
		}
		 ],
        processVersion: 2017,
        edDraftURI: "https://github.com/BorderCloud/tft-reports",
        shortName: "tft-reports",
	previousURI: "https://w3c.github.io/rdf-tests/sparql11/",
          lint: false
      };
    </script>
  </head>
  <body>

	<section id='abstract'><h2 id="abstract-0">Abstract</h2>
		<p>
			This document defines the format of the tests in the SPARQL test suite and lists
			test results from docker instances of RDF databases on GitHub that have evaluated by the tool TFT via Travis CI.
		</p>
	</section>

    <section id="sotd" class="introductory"><h2 id="status-of-this-document">Status of This Document</h2>
      <p>
        This document is merely a <abbr title="World Wide Web Consortium">W3C</abbr>-internal  document. It
        has no official standing of any kind and does not represent consensus of the <abbr title="World Wide Web Consortium">W3C</abbr>
        Membership.
      </p>
  </section>

	<section>
		<h2>Namespace prefixes</h2>
		<p>
			In this document we will employ the following namespace prefixes:
		</p>

		<dl>
			<dt><code>earl</code></dt>
			<dd><code><a href="http://www.w3.org/ns/earl#">http://www.w3.org/ns/earl#</a></code></dd>
		</dl>

	</section>

<section>
	<h2>Test Cases Format and Process</h2>

  	<div class="issue" id="issue-A">
			<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
				<span>TODO A</span><span style="text-transform: none"></span>
			</div>
			<div class="">
			  <p>
			  changer cette partie
			  </p>
			</div>
		</div>
  <p>


<section>
The
<a href="http://www.w3.org/2009/sparql/wiki/">SPARQL Working Group</a> uses a test-driven process.&nbsp; The <a href="http://www.w3.org/2009/sparql/docs/tests">test area</a> is a
collection of the current test cases of the working group extending and updating the <a href="http://www.w3.org/2001/sw/DataAccess/tests/r2">testcases</a> of the <a href="http://www.w3.org/2001/sw/DataAccess/">Data Access Working Group</a>. </p>
  <p>
Tests are divided into collections (corresponding to directories) for manageability.&nbsp; Each collection
of tests has a <em>manifest file</em> within its directory (usually named
<tt>manifest.ttl</tt>, but sometimes <tt>manifest.n3</tt>).
There is also a number of overall manifests containing entries pointing to the
individual test collection manifests:</p>

<ul>
<li><a
href="http://www.w3.org/2001/sw/DataAccess/tests/data-r2/manifest-syntax.ttl">manifest
of syntax-only tests</a> (positive and negative tests) for the <a href="http://www.w3.org/TR/rdf-sparql-query/">SPARQL1.0 Query Language</a></li>
<a
href="http://www.w3.org/2001/sw/DataAccess/tests/data-r2/manifest-evaluation.ttl">manifest
of query-evaluation tests</a> for the <a href="http://www.w3.org/TR/rdf-sparql-query/">SPARQL1.0 Query Language</a>.</li>
<li><a href="http://www.w3.org/2009/sparql/docs/tests/data-sparql11/manifest-sparql11-query-syntax.ttl">manifest of syntax-only tests</a> (positive and negative tests) for the <a href="http://www.w3.org/TR/sparql11-query/">SPARQL1.1 Query Language</a></li>
  <li><a
href="http://www.w3.org/2009/sparql/docs/tests/data-sparql11/manifest-sparql11-query-evaluation.ttl">manifest of query evaluation tests</a> for the <a href="http://www.w3.org/TR/sparql11-query/">SPARQL1.1 Query Language</a></li>
  <li><a
href="data-sparql11/entailment/manifest.ttl">manifest of entailment evaluation tests</a> for the <a href="http://www.w3.org/TR/sparql11-entailment/">SPARQL1.1 Entailment Regimes</a></li>
  <li><a href="http://www.w3.org/2009/sparql/docs/tests/data-sparql11/manifest-sparql11-update-syntax.ttl">manifest of syntax-only tests</a> (positive and negative tests) for the <a href="http://www.w3.org/TR/sparql11-update/">SPARQL1.1 Update Language</a></li>
  <li><a
href="http://www.w3.org/2009/sparql/docs/tests/data-sparql11/manifest-sparql11-update-syntax.ttl">manifest of update evaluation tests</a> for the <a href="http://www.w3.org/TR/sparql11-update/">SPARQL1.1 Update Language</a></li>
  <li><a
href="data-sparql11/service-description/manifest.ttl">manifest of service description tests</a> for the <a href="http://www.w3.org/TR/sparql11-service-description/">SPARQL1.1 Service Description</a></li>
</ul>

    <div id="result-manifest"
         data-sgvizler-query="PREFIX mf: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt;
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
prefix rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;

SELECT  ?label (group_concat(DISTINCT ?manifest) as ?manifests)
WHERE {
GRAPH &lt;http://w3c.github.io/rdf-tests/sparql11/data-sparql11/&gt;  {
        ?spec  mf:conformanceRequirement   ?collection .
        ?spec  rdfs:label   ?label .
        ?collection 	rdf:rest*/rdf:first  ?manifest .
     }
}
GROUP BY ?label
ORDER BY ?label
"
         data-sgvizler-endpoint="http://134.158.74.247/test/query"
         data-sgvizler-chart="bordercloud.visualization.DataTable"
         data-sgvizler-log="2"
         data-sgvizler-method="POST"
    ></div>

</section>

<section>
<h4><a name="organization" id="organization"/>Organization</a></h4>
<p>
The test cases are organised in two directories</p>
<ul>
  <li>The <a href="http://www.w3.org/2009/sparql/docs/tests/data-r2/">data-r2</a> directory holds the testcases from the previous <a href="http://www.w3.org/2001/sw/DataAccess/tests/r2">testcases</a>SPARQL1.0 Query language test suite @@@plus new tests that are restricted to SPARQL 1.0 features only??? @@@.</li>
  <li>The <a href="http://www.w3.org/2009/sparql/docs/tests/data-sparql11">data-sparql11</a> directory holds test cases aimed at covering as much of the SPARQL 1.1 Query Language and SPARQL 1.1 Update Language as possible.</li>
</ul>
  The purpose is to provide an up-to-date, upwards-compatible, consistent, and easy-to-use suite of test cases that SPARQL 1.1 implementors can use to evaluate and report on their
implementation.
</p>
<p>
The tests as-is shall constitute a test suite that the group will
use to generate an implementation report for the SPARQL1.1 Query  and SPARQL1.1 Update languages.</p>
<p><b>@@@ What about other tests, will we use the same structure for e.g. http-update, service-description tests, will we (a) have separate manifest(s) for entailment?</b></p>
</p>
</section>

<section>
  <h4><a name="vocabularies" id="vocabularies"/>Manifest Vocabularies</a></h4>

  <p>The SPARQL1.1 test manifest files define five vocabularies to express
  tests and results:</p>

  <ol>
    <li><a href="http://www.w3.org/2001/sw/DataAccess/tests/test-manifest.n3">manifest vocabulary</a> (prefixed with
    <tt>mf:</tt> below)</li>
    <li><a href="http://www.w3.org/2001/sw/DataAccess/tests/test-query.n3">query evaluation test vocabulary</a> (prefixed
    with <tt>qt:</tt> below)</li>
    <li><a href="test-update.n3">update evaluation test vocabulary</a> (prefixed
    with <tt>ut:</tt> below)</li>
    <li><a href="http://www.w3.org/2001/sw/DataAccess/tests/test-dawg.n3">DAWG test approval vocabulary</a> (prefixed
    with <tt>dawgt:</tt> below)</li>
    <li><a href="http://www.w3.org/2001/sw/DataAccess/tests/test-dawg.n3">DAWG result-set RDF vocabulary</a> (prefixed
    with <tt>rs:</tt> below)</li>
  </ol>

  <p>All examples below use these prefix bindings (specified in <a
  href="http://www.w3.org/2001/sw/DataAccess/df1/">turtle</a>):</p>

  <pre class="diag">@prefix rdf:     &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix rdfs:    &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix mf:      &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt; .
@prefix dawgt:   &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-dawg#&gt; .
@prefix qt:      &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-query#&gt; .
@prefix ut:      &lt;http://www.w3.org/2009/sparql/tests/test-update#&gt; .
@prefix sd:      &lt;http://www.w3.org/ns/sparql-service-description#&gt; .
@prefix ent:     &lt;http://www.w3.org/ns/entailment/RDF&gt; .
@prefix rs:      &lt;http://www.w3.org/2001/sw/DataAccess/tests/result-set#&gt; .
  </pre>

  <h4><a name="structure" id="structure"/>Manifest Structure</a></h4>

  <p>
A manifest is a list (RDF Collection) of tests. Every test has
a name (<tt>mf:name</tt>); many tests also have a comment
(<tt>rdfs:comment</tt>) explaining the purpose of the test.
The <tt>dawgt:approval</tt> predicate relates a test to its official
Working Group status (e.g. <tt>dawgt:Approved</tt>).
Tests are grouped (via their <tt>rdf:type</tt>) as:
</p>

<ul>
	<li>positive SPARQL 1.0 Query syntax tests (<tt>mf:PositiveSyntaxTest</tt>)</li>
	<li>positive SPARQL 1.1 Query syntax tests (<tt>mf:PositiveSyntaxTest11</tt>)</li>
	<li>positive SPARQL 1.1 Update syntax tests (<tt>mf:PositiveUpdateSyntaxTest11</tt>)</li>
	<li>negative SPARQL 1.0 Query syntax tests (<tt>mf:NegativeSyntaxTest</tt>)</li>
	<li>negative SPARQL 1.1 Query syntax tests (<tt>mf:NegativeSyntaxTest11</tt>)</li>
	<li>negative SPARQL 1.1 Update syntax tests (<tt>mf:NegativeUpdateSyntaxTest11</tt>)</li>
	<li>SPARQL 1.0 and 1.1 Query evaluation tests (<tt>mf:QueryEvaluationTest</tt>)</li>
	<li>SPARQL 1.1 Update evaluation tests (<tt>mf:UpdateEvaluationTest</tt>)</li>
	<li>CSV Result Format tests (<tt>mf:CSVResultFormatTest</tt>)</li>
	<li>SPARQL 1.1 Service Description tests (<tt>mf:ServiceDescriptionTest</tt>)</li>
</ul>
</section>

<section>
  <h4><a name="filenames" id="filenames"/>File Names</a></h4>

 <p>Typically, in the test case suite, we use the following suffixes to indicate different file types:</p>
 <ul>
    <li><b>.ttl</b> ... Files describing RDF graphs in <a href="http://www.w3.org/TeamSubmission/turtle/">Turtle</a> syntax.
    </li>
    <li><b>.rdf</b> ... Files describing RDF graphs in <a href="http://www.w3.org/TR/rdf-syntax-grammar/">RDF/XML</a> syntax.
    </li>
    <li><b>.rq</b> ... Files containing a <a href="http://www.w3.org/TR/sparql11-query/">SPARQL1.1 Query</a> request.
    </li>
    <li><b>.ru</b> ... Files containing a <a href="http://www.w3.org/TR/sparql11-update/">SPARQL1.1 Update</a> request.
    </li>
    <li><b>.srx</b> ... Files containing a query result in the <a href="http://www.w3.org/TR/rdf-sparql-XMLres/">SPARQL Query Results XML Format</a>.
    </li>
    <li><b>.srj</b> ... Files containing a query result in the <a href="http://www.w3.org/TR/sparql11-results-json/">SPARQL 1.1 Query Results JSON Format</a>.
    </li>
    <li><b>.csv</b> ... Files containing a query result in the <a href="http://www.w3.org/TR/sparql11-results-csv-tsv/">SPARQL 1.1 Query Results CSV (Comma Separated Values) Format</a>.
    </li>
    <li><b>.tsv</b> ... Files containing a query result in the <a href="http://www.w3.org/TR/sparql11-results-csv-tsv/">SPARQL 1.1 Query Results TSV (Tab Separated Values) Format</a>.
    </li>
  </ul>
<p>@@@ Fix/check final URL for http://www.w3.org/TR/sparql11-results-json/!</p>

 <p>@@@ Will we update the SPARQL Query Results XML Format spec for SPARQL1.1?</p>
</section>

<section>
  <h4><a name="syntaxtests" id="syntaxtests"/>Syntax Tests</a></h4>

  <p>
Each syntax test has an <tt>mf:action</tt>, the object of which is a
resource identifying a (possible) query string. An example definition of a
syntax test is:
  </p>

<pre class="diag">
&lt;#syntax-basic-01&gt;  mf:name  "syntax-basic-01.rq" ;
     rdf:type   mf:PositiveSyntaxTest ;
     mf:action  &lt;syntax-basic-01.rq&gt; ;
     dawgt:approvedBy &lt;http://lists.w3.org/Archives/Public/public-rdf-dawg/2007JanMar/0047&gt; ;
     dawgt:approval dawgt:Approved .
</pre>

<p>
A SPARQL implementation passes a <tt>mf:PositiveSyntaxTest</tt> if it parses
the query string without error. A SPARQL implementation passes a
<tt>mf:NegativeSyntaxTest</tt> if it raises an error while attempting to parse
the query string.
</p>
</section>

<section>
  <h4><a name="queryevaltests" id="queryevaltests"/>Query Evaluation Tests</a></h4>

  <p>Each query evaluation test has an <tt>mf:action</tt> and an
  <tt>mf:result</tt>. The object of <tt>mf:action</tt> is a resource with
  properties taken from the query evaluation test vocabulary. At a minimum, a
  test's action includes  a <tt>qt:query</tt>
  relation and an optional <tt>qt:data</tt> relation. The <tt>qt:data</tt>
  predicate points to a URI that can be dereferenced to yield the
  default graph for the test. The <tt>qt:query</tt> prediate points to a
  URI that can be dereferenced to yield the query string for the test. Query evaluation tests may also use the <tt>qt:graphData</tt> predicate to indicate the named graph components of the test's RDF dataset.</p>

  <p>In case the query in the <tt>qt:query</tt> predicate contains  <tt>FROM</tt> and <tt>FROM NAMED</tt> clauses and no <tt>qt:data</tt> is present, the graphs comprising the test's RDF dataset are expected to be loaded by dereferencing the respective URIs of the <tt>FROM/FROM NAMED</tt> clauses.</p>

  <p>Query evaluation tests also contain an <tt>mf:result</tt> which points to
  a URI that can be dereferenced to yield the
  expected results of the test query. These results are expressed in one of
  several possible ways:</p>

  <ul>
    <li>The <a href="http://www.w3.org/TR/rdf-sparql-XMLres/">SPARQL Query
    Results XML Format</a>. SELECT or ASK queries.</li>
    <li>The <a href="http://www.w3.org/TR/sparql11-results-json/">SPARQL Query
    Results JSON Format</a>. SELECT or ASK queries.</li>
    <li>The <a href="http://www.w3.org/TR/sparql11-results-csv-tsv/#tsv">SPARQL Query
    Results TSV Format</a>. SELECT or ASK queries. (As for testing the <a href="http://www.w3.org/TR/sparql11-results-csv-tsv/#csv">SPARQL Query
    Results CSV Format</a>, see the separate Section within this document on <a href="#csvtests">CSV Result Format Tests</a>).</li>
    <li>The <a href="http://www.w3.org/2001/sw/DataAccess/tests/result-set.n3">DAWG result-set RDF vocabulary</a>.
    SELECT or ASK queries.</li>
    <li><a href="http://www.w3.org/TR/rdf-syntax-grammar/">RDF/XML</a> or <a
    href="http://www.dajobe.org/2004/01/turtle/">Turtle</a>. CONSTRUCT queries.</li>
  </ul>

<p>A SPARQL implementation passes a query evaluation test if the graph
produced by evaluating the query against the RDF dataset (and encoding in the
DAWG result set vocabulary, if necessary) is
<a href="http://www.w3.org/TR/rdf-concepts/#section-graph-equality">equivalent</a> [RDF-CONCEPTS]
to the graph named in the result (after encoding in the DAWG result set
vocabulary, if necessary).  Note that, solution order only is considered relevant, if the result is expressed in the test suite in the DAWG result set vocabulary, with explicit <code>rs:index</code> triples; otherwise solution order is considered irrelevant for passing. Equivalence can be tested by
checking that the graphs are isomorphic and have identical IRI and
literal nodes. Note that testing whether two result sets are isomorphic is simpler than full graph isomorphism. Iterating over rows in one set, finding a match with the other set, removing this pair, then making sure all rows are accounted for, achieves the same effect. </p>

<p>Query evaluation tests that involve the <a href="http://www.w3.org/TR/rdf-sparql-query#modReduced">REDUCED</a> keyword have slightly different passing criteria. These tests are indicated in the manifest files with the <tt>mf:resultCardinality</tt> predicate with an object of <tt>mf:LaxCardinality</tt>. To pass such a test, the result set produced by a SPARQL implementation must contain each solution in the expected result set at least once and no more than the number of times that the solution occurs in the expected result set. (That is, the expected result set contains the solutions with cardinalities as they would be if the query did not contain REDUCED; to pass the test, an implementation must produce the correct results with cardinalities between one and the cardinlity in the expected result set.)</p>

<p>An example definition of a query evaluation test is:</p>

<pre class="diag">
&lt;#dawg-regex-002&gt; a mf:QueryEvaluationTest ;
      mf:name    "regex-query-002" ;
      dawgt:approval dawgt:Approved ;
      dawgt:approvedBy &lt;http://lists.w3.org/Archives/Public/public-rdf-dawg/2007AprJun/0029.html&gt; ;
      rdfs:comment
          "Case insensitive unanchored match test" ;
      mf:action
          [ qt:query  &lt;regex-query-002.rq&gt; ;
            qt:data   &lt;regex-data-01.n3&gt; ] ;
      mf:result  &lt;regex-result-002.n3&gt; .
</pre>
</section>

<section>
  <h4><a name="csvtests" id="csvtests"/>CSV Result Format Tests</a></h4>

  <p>
CSV Result Format tests are meant to test a SPARQL implementation's ability to serialize query results in the SPARQL 1.1 Query Results CSV Format.
This is a lossy format, however, and so cannot be tested in the same manner as the other result formats.
Care should be taken to ensure that results produced in the CSV format are compared properly to the expected result values.
In all other respects, CSV tests should be treated as <a href="#queryevaltests">query evaluation tests</a>.
  </p>

<p>An example result set in the CSV Format is:</p>
<pre class="diag">
s,p,o
http://example.org/s2,http://example.org/p2,2.2
</pre>

<p>Due to the lossy nature of the CSV format, the single expected result could match any of the following actual results:</p>

<ul>
	<table class="plain">
	<tr>
		<th>s</th>
		<th>p</th>
		<th>o</th>
	</tr>
	<tr>
		<td>&lt;http://example.org/s2&gt;</td>
		<td>&lt;http://example.org/p2&gt;</td>
		<td>"2.2"</td>
	</tr>
	<tr>
		<td>&lt;http://example.org/s2&gt;</td>
		<td>&lt;http://example.org/p2&gt;</td>
		<td>"2.2"^^xsd:string</td>
	</tr>
	<tr>
		<td>&lt;http://example.org/s2&gt;</td>
		<td>&lt;http://example.org/p2&gt;</td>
		<td>"2.2"^^xsd:decimal</td>
	</tr>
	</table>
</ul>



</section>

<section>
  <h4><a name="entailevaltests" id="entailevaltests"/>Entailment Evaluation Tests</a></h4>

<p>Entailment Evaluation tests are special query evaluation tests that additionally (slightly ab-)use the <tt>sd:entailmentRegime</tt> and, optionally, the <tt>sd:entailmentProfile</tt> properties from the <a href="http://www.w3.org/TR/sparql11-service-description/">SPARQL 1.1 Service Description<a> vocabulary to further specify the  object of the <tt>mf:action</tt> property, indicating the expected entailment regime for graphs in the dataset and, where applicable, which OWL profile that test satisfies.</p>

<p>A SPARQL implementation passes a query evaluation test if its
answers over any graphs in the dataset using the <tt>sd:entailmentRegime</tt>
property comply with the criteria formalised in the
<a href="http://www.w3.org/TR/sparql11-entailment/">SPARQL 1.1 Entailment Regimes<a> document. Apart from that, passing tests is as defined for query evaluation tests.</p>

<p>An example definition of an entailment evaluation test for the RDF entailment regime is:</p>

<pre class="diag">
:rdf01 rdf:type mf:QueryEvaluationTest ;
    mf:name    "RDF inference test" ;
    dawgt:approval dawgt:NotClassified ;
    mf:action
         [ qt:query  &lt;rdf01.rq&gt; ;
           qt:data   &lt;rdf01.ttl&gt;
           sd:entailmentRegime ent:RDF ] ;
    mf:result  &lt;rdf01.srx&gt;
    .
 </pre>

<p>Instead of a single entailment regime, tests can also be marked with a list of regimes. In this case,
any of the entailment regimes can be used to run the test. Similarly, the supported OWL profiles can be given as a
list or as a single value:</p>

<pre class="diag">
    :sparqldl-10  rdf:type   mf:QueryEvaluationTest ;
         mf:name  "sparqldl-10.rq: undist vars test" ;
         mf:action
                [ qt:query  <sparqldl-10.rq> ;
                qt:data <data-07.ttl> ;
           sd:EntailmentProfile ( pr:DL pr:EL pr:Full ) ;
           sd:entailmentRegime ( ent:OWL-Direct ent:OWL-RDF-Based )  ] ;
         mf:result  <sparqldl-10.srx> .
</pre>

<p>Note that, strictly speaking, this use of the <tt>sd:entailmentRegime</tt></a> property - by its specified <a href="http://www.w3.org/TR/sparql11-service-description/#sd-entailmentRegime">domain</a> - makes the object of the <tt>mf:action</tt> attribute a member of the <tt>sd:NamedGraph</tt> class; the <tt>sd:NamedGraph</tt> class though has no meaning within the context of test cases, so this domain specification can be savely ignored.</p>

</section>

<section>
  <h4><a name="updateevaltests" id="updateevaltests"/>Update Evaluation Tests</a></h4>

  <p>Each update evaluation test has an <tt>mf:action</tt> and an
  <tt>mf:result</tt>. The object of <tt>mf:action</tt> for an Update evaluation test case is a resource with properties taken from the update evaluation test vocabularies.
  The latter is used among others to describe the graph store's state before and after the execution of an update.  At a minimum, a test's action includes a <tt>ut:request</tt> relation.</p>

<p>The optional <tt>ut:data</tt> and <tt>ut:graphData</tt> relations within the <tt>mf:action</tt> of an update test case point the status of the <a href="http://www.w3.org/TR/sparql11-update/#sec_graphStore">Graph Store</a> <i>prior</i> to the update execution described in terms of at most one <tt>ut:data</tt> property denoting the unnamed graph and optional <tt>ut:graphData</tt> properties denoting named graphs.
 The object of the <tt>ut:data</tt> property is a URI reference to an RDF graph, whereas the objects of the <tt>ut:graphData</tt> property indicate the named graph components of the Graph Store. Named graphs are described either - analogous to the <tt>qt:graphData</tt> property from the query test vocabulary - by explicit URI reference (in which case the graph name is supposed to correspong to the respective URI reference), or the object of the <tt>ut:graphData</tt> property may be a resource further described in terms of an <tt>ut:graph</tt> and an <tt>rdfs:label</tt> property. Here, the <tt>ut:graph</tt> property is a URI reference to an RDF graph, whereas the <tt>rdfs:label</tt> property with plain literal value indicates the graph's name under which it is accessible in the graph store. The ability to assign a "name" different from the URI reference name explicitly to a named graph in a graph store is needed to denote different graphs by the same name to describe the status of a named graph prior and after execution of an update.</p>

<p>In the case of absence of both <tt>ut:data</tt> and <tt>ut:graphData</tt> properties within the <tt>mf:action</tt>, the graph store is supposed to be empty (i.e., with an empty default graph and no named graphs) prior to execution of the update.
</p>

<p>
The
  <tt>ut:request</tt> predicate points to a URI that can be dereferenced to yield
  the update query string for the test.</p>

  <p>Update evaluation tests also contain an <tt>mf:result</tt>. The object of <tt>mf:result</tt> is a resource described in terms of the <tt>ut:data</tt> and <tt>ut:graphData</tt> properties. The optional <tt>ut:data</tt> and <tt>ut:graphData</tt> properties within a an update evaluation test result denote the state of the graphstore <i>after</i> execution of the query analogous to the  <tt>ut:data</tt> and <tt>ut:graphData</tt> properties occurring in the <tt>mf:action</tt> of an update evaluation test.
In the case of absence of both <tt>ut:data</tt> and <tt>ut:graphData</tt> properties within the <tt>mf:result</tt>, the graph store is supposed to be empty after execution of the update.
</p>

<p>A SPARQL implementation passes a update evaluation test if the graphs in the graph store are
<a href="http://www.w3.org/TR/rdf-concepts/#section-graph-equality">equivalent</a> [RDF-CONCEPTS]
to the graphs denoted in the <tt>mf:action</tt> (and <tt>mf:result</tt>) property, respectively) prior to the update execution (after update execution, respectively). Equivalence can be tested as described above for query evaluation tests.</p>

<p>An example definition of an update evaluation test is:</p>

<pre class="diag">
:insert-data-spo1 a mf:UpdateEvaluationTest ;
    mf:name    "Simple insert data 1" ;
    rdfs:comment "This is a simple insert of a single triple to the unnamed graph of an empty graph store" ;
    dawgt:approval dawgt:NotClassified ;
    mf:action [
                ut:request &lt;insert-data-spo1.ru&gt; ;
                ut:data &lt;empty.ttl&gt;
              ] ;
    mf:result [
                ut:data  &lt;spo.ttl&gt;
              ] .
</pre>
</section>

<section>
<h4><a name="servicetests" id="servicetests"/>Federated Query Tests</a></h4>

<p>In SPARQL 1.1 Federated Query, tests cases contain new vocabulary not used before. These tests check whether the queries with that operator are correct or not. Queries using the <code>SERVICE</code> keyword for accessing remote SPARQL endpoints need a way to describe the data comming from these endpoints which was not previously defined.</p>

<p>The predicate <code>qt:serviceData</code> helps to describe the data comming from these remote SPARQL endpoints in a query. This predicate can also contain the predicate <code>qt:endpoint</code> which contains the URL of the remote SPARQL endpoint.</p>

<p>An example definition of a Federated Query test is:</p>

<pre class="diag">
:service1 rdf:type mf:QueryEvaluationTest ;
       mf:name    "SERVICE test 1" ;
       dawgt:approval dawgt:NotClassified ;
       mf:feature sd:BasicFederatedQuery ;
       mf:action [
               qt:query  &lt;service01.rq&gt; ;
               qt:data   &lt;data01.ttl&gt; ;
               qt:serviceData [
                       qt:endpoint &lt;http://example.org/sparql&gt; ;
                       qt:data     &lt;data01endpoint.ttl&gt;
               ]
       ] ;
       mf:result  &lt;service01.srx&gt; .</pre>


</section>

<section>
<h4><a name="protocoltests" id="protocoltests"/>Protocol Tests</a></h4>

<p>A testing service for <a href="http://www.w3.org/TR/sparql11-protocol/">SPARQL 1.1 Protocol</a> implementations has been set up at <tt><a href="http://www.w3.org/2009/sparql/protocol_validator">http://www.w3.org/2009/sparql/protocol_validator</a></tt>. The service and tests performed by this service are described in a <a href="https://github.com/kasei/sparql11-protocolvalidator">separate document</a>.</p>
</section>

<section>
<h4><a name="servicedescriptiontests" id="servicedescriptiontests"/>Service Description Tests</a></h4>

<p>A testing service for SPARQL 1.1 Protocol implementations supporting <a href="http://www.w3.org/TR/sparql11-service-description/">SPARQL 1.1 Service Descriptions</a> has been set up at <tt><a href="http://www.w3.org/2009/sparql/sdvalidator">http://www.w3.org/2009/sparql/sdvalidator</a></tt>. The service performs a number of tests to verify that a submitted endpoint returns RDF that conforms to the service description vocabulary specification. Using content negotiation to request RDF (supporting both Turtle and RDF/XML), the service can be used to generate an <a href="http://www.w3.org/2001/sw/DataAccess/tests/earl">EARL implementation report</a>.</p>
</section>

<section>
<h4><a name="graphstoreprotocoltests" id="graphstoreprotocoltests"/>Graph Store HTTP Protocol Tests</a></h4>

<p>A number of test cases for the <a href="http://www.w3.org/TR/sparql11-http-rdf-update/">SPARQL 1.1 Graph Store HTTP Protocol</a> consisting of HTTP requests and expected responses are described in a <a href="http://www.w3.org/2009/sparql/docs/tests/data-sparql11/http-rdf-update/">separate document</a>.</p>
</section>

<section>
  <h4><a name="testannotations" id="testannotations"/>Test annotations</a></h4>

<p>@@@ This section might need reconsideration to reflect extensions (like new library functions) that have become standard in SPARQL1.1 @@@</p>
  <h5>mf:requires</h5>
  <p>A number of tests in the open-world directory illustrate features of SPARQL
  by depending on how a SPARQL query processor can extend the set of core types
  and operations as defined by the operator table [<a href="http://www.w3.org/TR/rdf-sparql-query/">http://www.w3.org/TR/rdf-sparql-query/#OperatorMapping</a>].</p>
  <p>These tests are marked by property <code>mf:requires</code> and an object value from one
  of the URIs described below.</p>
  <dl>
    <dt><code>mf:XsdDateOperations</code></dt>
    <dd>Requires the processor to understand comparisons of
    literal of type xsd:date. Without providing operations on the xsd:date datatype, a
    processor would raise an error&nbsp;on the operations of &quot;=&quot; and &quot;!=&quot;
    etc. With
    an understanding of xsd:date, a processor can perform value-based operations
    and provide the operations described in &quot;XQuery 1.0 and XPath 2.0 Functions
    and Operators&quot; (e.g. <a href="http://www.w3.org/TR/xpath-functions/">
    date-equals</a> <a href="http://www.w3.org/TR/xpath-functions/">
    date-less-than</a>)</dd>

	<dt><code>mf:StringSimpleLiteralCmp</code></dt>
    <dd>This indicates that the test uses the fact that plain literals, without
    language tags test are the same value as an <code>xsd:string</code> with the same
    lexicial form. This is covered by rules &quot;xsd 1a&quot; and &quot;xsd 1b&quot; from RDF
    Semantics [<a href="http://www.w3.org/TR/rdf-mt/">http://www.w3.org/TR/rdf-mt/#DtypeRules</a>].</dd>

    <dt><code>mf:KnownTypesDefault2Neq</code></dt>
    <dd>This indicates that a processor extends the SPARQL operator model by
    using the fact that values of literals can be in disjoint value spaces and
    hence can not be equal by value. For example, an xsd:integer can not be the
    same value as an xsd:boolean because these two datatypes define disjoint
    value spaces.</dd>

<dt><code>mf:LangTagAwareness</code></dt>
	<dd>This indicates that the test assumes the SPARQL query processor has support
for plain literals with language tags.  The minimum set of operators in the
    <a href="http://www.w3.org/TR/rdf-sparql-query/#OperatorMapping">SPARQL operator table</a>
does not include language tag handling, only plain literals without language
tag (simple literals) and certain XSD datatypes.

</dl>

    <h5>mf:notable</h5>
  <p>This annotation indicates a feature of SPARQL that implementers might note:</p>
  <dl>
    <dt><code>mf:IllFormedLiteral</code></dt>
    <dd>The test involves handling of ill-formed literals.</dd>

</dl>
</section>

<section>
  <h4><a name="howto" id="howto"/>How to run the Test Cases</a></h4>


<p><b>@@@ This section shall contain some hints on how to actually run the test suite and generate implementation reports for implementers.</b></p>

    <p>&nbsp;</p>

</section>
    ---------------------------------------------------------------------------------------------------------------------------------------------

	<section>
		<h3>Manifest format</h3>
  		<p>
  			The tests are available in the folder structure starting at
  			<a href="https://github.com/w3c/data-shapes/tree/gh-pages/data-shapes-test-suite/tests">tests</a>.
    		Each folder contains one or more manifest files that describe the tests in that folder.
    	</p>
		<p>
			The manifest file is defined in RDF and is compatible with the manifest used by other W3c initiatives like
	         <a href="www.w3.org/2011/rdf-wg/wiki/RDF_Test_Suites">RDF 1.1</a> or
	         <a href="http://www.w3.org/2001/sw/DataAccess/tests/r2">SPARQL</a>
	     </p>

<pre data-lang="text/turtle">
&lt;&gt; a mf:Manifest ;
     rdfs:label "...Manifest label"
     rdfs:comment "...Manifest comment" ;
     dc:creator "...creator..."
     mf:entries
     (
     ....list of ManifestEntries
     ) .</pre>
	<p>Each manifest entry is a single test which can be one of the following types:</p>
		<ul>
		<li><a href="#Validate">Validate RDF data</a>
		</ul>
	</section>

	<section>
		<h3 id="Validate">Validate RDF data</h3>
		<p>
			These tests verify that the validation of a given data graph against a given shapes graph produces
			a specified validation report.
			Both the data graph and the shapes graph may be identical.
		</p>
		<p>
			Example:
		</p>
<pre data-lang="text/turtle">
&lt;entry1&gt; a sht:Validate ;
   mf:name "Validate simple RDF data with a simple shapes graph" ;
   mf:action [
        sht:shapesGraph &lt;example-shapes.ttl&gt; ;
        sht:dataGraph &lt;example-data.ttl&gt; ;
   ] ;
   mf:result [
        a sh:ValidationReport ;
        sh:conforms true ;
   ] ;
   mf:status sht:proposed .
</pre>
		<p>
			To perform the test, a validation engine must validate the data graph specified by <code>sht:dataGraph</code>
			against the shapes graph specified by <code>sht:shapesGraph</code>.
			The values of both must be relative URLs pointing at a Turtle file in the same directory as the test file itself.
			It is also valid that either of these graphs point at the manifest graph itself, using the relative URL <code>&lt;&gt;</code>.
		</p>
		<p>
			Implementations may report two levels of compliance:
		</p>
		<ul>
			<li>
				<dfn>partial compliance</dfn> means that an implementation is able to perform conformance checking only,
				i.e. produces the same boolean value for <code>sh:conforms</code> as required by the expected report.
			</li>
			<li>
				<dfn>full compliance</dfn> means that an implementation can produce a complete validation report
				that can be compared with the expected validation report as described in the remainder of this section.
			</li>
		</ul>
		<p>
			For <a>full compliance</a>:
			Let <code>R</code> be the blank node that is the value of <code>mf:result</code> of the <code>sht:Validate</code> test case
			in the manifest graph.
			Let <code>expected</code> be the graph that consists of all triples from the manifest graph that have <code>R</code> as subject
			plus all triples that have all values of <code>sh:result</code> of <code>R</code> as their subject,
			as well as any triples needed to correctly represent the <code>sh:resultPath</code>.
		</p>
		<p>
			Let <code>actual</code> be the results graph produced by the validation, i.e. the validation report.
			The test framework may post-process this results graph to ensure the following preconditions.
			Before comparing the results graph with the <code>expected</code> results, the <code>actual</code> validation report
			must not include any "nested" results, via <code>sh:details</code>.
			The <code>actual</code> results also must not depend on subclass relationships, so that instances of subclasses of
			<code>sh:ValidationReport</code> and <code>sh:ValidationResult</code> must have these as their (only) <code>rdf:type</code> values.
			Also, all instances of <code>sh:ValidationResult</code> and <code>sh:ValidationReport</code> must be blank nodes,
			i.e. if the engine produces URIs then these need to be replaced with blank nodes.
			Also, the blank node structures representing property paths via <code>sh:resultPath</code> must not be shared among
			multiple results, i.e. they may need to be cloned prior to comparison.
			Blank node structures representing property paths via <code>sh:resultPath</code> must not reuse the same path blank node
			(as values of <code>sh:inversePath</code> etc) in multiple places - these need to be normalized before the comparison,
			i.e. share blank node structures need to be cloned into new blank nodes.
			Furthermore, only the following predicates are used by triples in the <code>expected</code> graph and therefore
			any other triples need to be removed from the <code>actual</code> graph prior to comparison:
		</p>
		<ul>
			<li><code>rdf:type sh:ValidationReport</code></li>
			<li><code>sh:result</code></li>
			<li><code>sh:conforms</code></li>
			<li><code>rdf:type sh:ValidationResult</code></li>
			<li><code>sh:focusNode</code></li>
			<li><code>sh:resultPath</code> (including depending blank node structures)</li>
			<li><code>sh:resultSeverity</code></li>
			<li><code>sh:sourceConstraint</code></li>
			<li><code>sh:sourceConstraintComponent</code></li>
			<li><code>sh:sourceShape</code></li>
			<li><code>sh:value</code></li>
		</ul>

    		<div class="issue" id="issue-2">
			<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
				<span>TODO</span><span style="text-transform: none"></span>
			</div>
			<div class="">
			  <p>
			  Faire la liste des classes et reprendre leurs descriptions
			  </p>
			</div>
		</div>

    		<div class="issue" id="issue-2">
			<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
				<span>TODO</span><span style="text-transform: none"></span>
			</div>
			<div class="">
			  <p>
			  Faire la liste des propriétés par classes et reprendre leurs descriptions
			  </p>
			</div>
		</div>

		<p>
			An exception is <code>sh:resultMessage</code>: As a general rule, all triples with <code>sh:resultMessage</code> as subject
			need to be removed from the <code>actual</code> graph, except those with object <code>?object</code> for which
			the <code>expected</code> graph contains a triple <code>?any sh:resultMessage ?object</code>.
			This makes sure that certain tests can verify that <code>sh:resultMessage</code> has been correctly
			populated from the <code>sh:message</code> triples in the shapes graph.
		</p>
		<p>
			To pass <a>full compliance</a>, the <code>actual</code> validation report must be <a href="https://www.w3.org/TR/rdf11-concepts/#graph-isomorphism">isomorphic</a> to <code>expected</code>.
			If the test case has <code>sht:Failure</code> as its value for <code>mf:result</code> then the test is passed if the validation reported a failure.
			Alternatively, implementation may still report pass if they have manually checked that their validation reports satisfy the requirements specified by the SHACL specification.
			The latter also applies to scenarios that are well-formed SHACL validation results according to [[!shacl]] while the
			test framework has stricter expectations.  For example, not all implementation are required to produce <code>sh:sourceShape</code> triples.
		</p>
		<p>
			In order to improve precision of comparing test results, blank nodes should be avoided as values
			of <code>sh:sourceShape</code> and <code>sh:sourceConstraint</code>.
		</p>
	</section>

	<section>
		<h3>Test Creation, Approval and Modification Process</h3>
		<p>
			Tests are maintained by members of the Working Group in the
			<a href="https://github.com/w3c/data-shapes/tree/gh-pages/data-shapes-test-suite/tests">GitHub</a> repository.
			Anyone, including non-members, can submit or suggest test cases via GitHub pull requests.
			Submissions by other means may be rejected without response.
			Test cases that have not been accepted by the Working Group yet must have <code>mf:status sht:proposed</code>.
		</p>
		<p>
			At the chair's discretion, individual tests or groups of tests are put to the Working Group,
			e.g. in the weekly telecon.
			The Working Group has complete discretion to approve or reject tests.
			Approved tests must have <code>mf:status sht:approved</code>, those that have been rejected
			may get marked as <code>mf:status sht:rejected</code> or deleted from the main branch of the repository.
			All approved tests must be reachable from the root manifest.mf file.
		</p>
		<p>
			Editors may modify test cases, but SHOULD go through the WG process for non-trivial changes.
		</p>
		<p>
			In addition to validation tests, we encourage users to submit examples of ill-formed shapes graphs.
			These may be used in the future to collect syntax tests.
		</p>
	</section>

	<section>
		<h3>Submitting Implementation Reports</h3>
		<p>
			Implementations listed here need to be submitted as a Turtle file in the format similar to the
			<a href="reports/topbraid-shacl-earl.ttl">TopBraid SHACL API EARL Report</a>.
			In a nutshell, we use [[EARL10-Schema]] to represent individual test results and metadata about the test subject.
			To indicate <a>full compliance</a>, use <code>earl:passed</code> as value for <code>earl:outcome</code>.
			To indicate <a>partial compliance</a> (i.e. can report <code>true</code> and <code>false</code>), use <code>sht:partial</code>.
		</p>
		<p>
			The preferred way of submitting test reports is via a pull request into the <a href="https://github.com/w3c/data-shapes/tree/gh-pages/data-shapes-test-suite/reports">reports</a> folder
			on GitHub.  Alternatively, send your Turtle file to the public comments mailing list.
		</p>
	</section>
</section>

	<section>
		<h2>Reports</h2>
		<p>
			This section summarizes the outcomes of test reports of SPARQL implementation in docker image hosted by GitHub.
		</p>

		<div class="issue" id="issue-1">
			<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
				<span>TODO 1</span><span style="text-transform: none"></span>
			</div>
			<div class="">
			  <p>
			  Faire une requête qui affiche le tableau des derniers logiciels testés :
			  Software 			Homepage			 Tests Updated
			  </p>
			</div>
		</div>

		<div class="issue" id="issue-1">
			<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
				<span>TODO 1</span><span style="text-transform: none"></span>
			</div>
			<div class="">
			  <p>
			  Faire la liste des erreurs pour ce logiciel coté syntaxe
			  </p>
			</div>
		</div>
		<div class="issue" id="issue-1">
			<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
				<span>TODO 1</span><span style="text-transform: none"></span>
			</div>
			<div class="">
			  <p>
			  Faire la liste des erreurs pour ce logiciel coté résultat
			  </p>
			</div>
		</div>

	</section>

  <section>
	<h2>Tests</h2>
  		<section>
		<h3>summary</h3>

    		<div class="issue" id="issue-2">
			<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
				<span>TODO 2</span><span style="text-transform: none"></span>
			</div>
			<div class="">
			  <p>
			  Faire une requête qui affiche les statistiques de chaque logiciel
			  Tests title	Link manifest		Software1(%) Software2(%)
			  </p>
			</div>
		</div>

		<div class="issue" id="issue-3">
			<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
				<span>TODO 3</span><span style="text-transform: none"></span>
			</div>
			<div class="">
			  <p>
			  Faire une requête qui affiche les statistiques de chaque logiciel
			  Tests title	Link manifest		Percent for all
			  </p>
			</div>
		</div>
   	</section>

   	<section>
      <h3>Tests by Specifications</h3>
      			<section>
				<h4>SPARQL 1.1 Query Language</h4>
				<p>

				</p>

			<div class="issue">
			<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
				<span>TODO </span><span style="text-transform: none"></span>
			</div>
			<div class="">
			  <p>
				  reproduire le tableau dans cette partie
				  http://w3c.github.io/rdf-tests/sparql11/reports/
			  </p>
			</div>
		</div>
			</section>
			<section>
				<h4>SPARQL 1.1 Update</h4>
				<p>

				</p>

				<div class="issue">
				<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
					<span>TODO </span><span style="text-transform: none"></span>
				</div>
				<div class="">
				  <p>
				  reproduire le tableau dans cette partie
				  http://w3c.github.io/rdf-tests/sparql11/reports/
				  </p>
				</div>
			</section>
			<section>
				<h4>SPARQL 1.1 Query Results CSV and TSV Formats</h4>
				<p>

				</p>

				<div class="issue">
				<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
					<span>TODO </span><span style="text-transform: none"></span>
				</div>
				<div class="">
				  <p>
				  reproduire le tableau dans cette partie
				  http://w3c.github.io/rdf-tests/sparql11/reports/
				  </p>
				</div>
			</section>
			<section>
				<h4>SPARQL 1.1 Query Results JSON Format</h4>
				<p>

				</p>

				<div class="issue">
				<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
					<span>TODO </span><span style="text-transform: none"></span>
				</div>
				<div class="">
				  <p>
				  reproduire le tableau dans cette partie
				  http://w3c.github.io/rdf-tests/sparql11/reports/
				  </p>
				</div>
			</section>
			<section>
				<h4>SPARQL 1.1 Federation Extensions</h4>
				<p>

				</p>

				<div class="issue">
				<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
					<span>TODO </span><span style="text-transform: none"></span>
				</div>
				<div class="">
				  <p>
				  reproduire le tableau dans cette partie
				  http://w3c.github.io/rdf-tests/sparql11/reports/
				  </p>
				</div>
			</section>
			<section>
				<h4>SPARQL 1.1 Entailment Regimes</h4>
				<p>

				</p>

				<div class="issue">
				<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
					<span>TODO </span><span style="text-transform: none"></span>
				</div>
				<div class="">
				  <p>
				  reproduire le tableau dans cette partie
				  http://w3c.github.io/rdf-tests/sparql11/reports/
				  </p>
				</div>
			</section>
			<section>
				<h4>SPARQL 1.1 Service Description</h4>
				<p>

				</p>

				<div class="issue">
				<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
					<span>TODO </span><span style="text-transform: none"></span>
				</div>
				<div class="">
				  <p>
				  reproduire le tableau dans cette partie
				  http://w3c.github.io/rdf-tests/sparql11/reports/
				  </p>
				</div>
			</section>
			<section>
				<h4>SPARQL 1.1 Protocol</h4>
				<p>

				</p>

				<div class="issue" >
				<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
					<span>TODO </span><span style="text-transform: none"></span>
				</div>
				<div class="">
				  <p>
				  reproduire le tableau dans cette partie
				  http://w3c.github.io/rdf-tests/sparql11/reports/
				  </p>
				</div>
			</section>
			<section>
				<h4>SPARQL 1.1 Graph Store HTTP Protocol</h4>
				<p>

				</p>

				<div class="issue">
				<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
					<span>TODO </span><span style="text-transform: none"></span>
				</div>
				<div class="">
				  <p>
				  reproduire le tableau dans cette partie
				  http://w3c.github.io/rdf-tests/sparql11/reports/
				  </p>
				</div>
			</section>
		</section>
	</section>
</section>

<section class="appendix" id="issue-summary">
  <!-- A list of issues will magically appear here -->
</section>


    <script src="node_modules/jquery/dist/jquery.slim.js"></script>
    <script src="node_modules/sgvizler2/build/browser/sgvizler2.js"></script>
    <script>

            sgvizler2.containerDrawAll();
    </script>
    <script
            src='https://www.w3.org/Tools/respec/respec-w3c-common'
            class='remove'></script>
  </body>
</html>
